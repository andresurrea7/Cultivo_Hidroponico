#include <Arduino.h>
#include <WiFi.h>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include "DHT.h"
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>

// =================== CONFIGURACIÃ“N FIREBASE ===================
#define ENABLE_USER_AUTH
#define ENABLE_DATABASE
#include <FirebaseClient.h>



// Objetos Firebase
WiFiClientSecure ssl_client;
AsyncClientClass async_client;
UserAuth user_auth(FIREBASE_API_KEY, FIREBASE_EMAIL, FIREBASE_PASSWORD);
FirebaseApp app;
RealtimeDatabase Database;

bool firebaseInitialized = false;
unsigned long lastFirebaseSend = 0;
const unsigned long FIREBASE_INTERVAL = 60000; // 1 minuto

// =================== CONFIGURACIÃ“N ===================
#define WIFI_SSID     "Poco Andres"
#define WIFI_PASSWORD "Andres1999"

// Pines sensores y actuadores
#define PH_PIN            10
#define SOIL_PIN          11
#define LED_WIFI_PIN      12
#define DHT_PIN           4
#define NIVEL_PIN         17
#define RELAY_BOMBA       18
#define RELAY_VALVULA     5

// DHT
#define DHTTYPE DHT22
DHT dht(DHT_PIN, DHTTYPE);

// =================== TELEGRAM ===================
#define BOT_TOKEN "8455839717:AAHnAR2C6LH_YLYbgEUoCTqUm8qy4YPD7C8"
#define CHAT_ID "1595976531"

// Lista de usuarios autorizados
//const char* CHAT_IDS[] = {"1595976531", "7162242048"}; //real
const char* CHAT_IDS[] = {"1595976531"};//prueba
const int NUM_CHAT_IDS = 1;

WiFiClientSecure client;
UniversalTelegramBot bot(BOT_TOKEN, client);

// =================== RTOS ===================
#define RTOS_DELAY(ms) vTaskDelay((ms) / portTICK_PERIOD_MS)

TaskHandle_t TaskSensorsHandle = NULL;
TaskHandle_t TaskRiegoHandle   = NULL;
TaskHandle_t TaskWifiHandle    = NULL;
TaskHandle_t TaskTelegramHandle = NULL;
TaskHandle_t TaskFirebaseHandle = NULL;

// =================== WIFI + NTP ===================
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "time.nist.gov", -5 * 3600, 60000);

// =================== VARIABLES GLOBALES ===================
volatile float lastPH = 0.0;
volatile int lastSoil = 0;
volatile float lastTemp = 0.0;
volatile float lastHum = 0.0;
volatile bool nivelAguaOK = false;
volatile bool wifiConectado = false;

// Control de sistema
volatile bool cicloActivo = false;
volatile unsigned long cicloStart = 0;
volatile bool bombaEncendida = false;
volatile bool llenandoTanque = false;
volatile bool valvulaManual = false;
volatile bool bombaManual = false;

// Control de tiempo
volatile unsigned long ultimaHoraSincronizada = 0;
volatile int ultimaHora = 7;
volatile int ultimoMinuto = 0;
volatile int ultimoSegundo = 0;
volatile bool horaSincronizada = false;

// Configuraciones del usuario
volatile unsigned long TIEMPO_RIEGO = 10 * 60 * 1000;
volatile unsigned long TIEMPO_DESCANSO = 8 * 60 * 1000;
volatile int HORA_INICIO_RIEGO = 7;
volatile int HORA_FIN_RIEGO = 17;
volatile int HORA_INICIO_LLENADO = 18;
volatile int HORA_FIN_LLENADO = 6;
volatile int HORA_ext_ini1 = 21;
volatile int HORA_ext_ini2 = 3;
volatile int HORA_ext_ini3 = 23;
volatile bool MEDIR_PH = true;

// Sensor de humedad del suelo
volatile int SOIL_WET_VALUE = 1200;
volatile int SOIL_DRY_VALUE = 4095;
volatile int lastSoilPercent = 0;

// =================== FUNCIONES AUXILIARES ===================
String formatTime(int hours, int minutes, int seconds) {
  String h = hours < 10 ? "0" + String(hours) : String(hours);
  String m = minutes < 10 ? "0" + String(minutes) : String(minutes);
  String s = seconds < 10 ? "0" + String(seconds) : String(seconds);
  return h + ":" + m + ":" + s;
}

bool autorizado(String id) {
  for (int i = 0; i < NUM_CHAT_IDS; i++) {
    if (id == CHAT_IDS[i]) return true;
  }
  return false;
}

void obtenerHoraActual(int &hora, int &minuto, int &segundo) {
  if (wifiConectado) {
    if (!horaSincronizada || (millis() - ultimaHoraSincronizada > 30 * 60 * 1000)) {
      if (timeClient.update()) {
        hora = timeClient.getHours();
        minuto = timeClient.getMinutes();
        segundo = timeClient.getSeconds();
        
        ultimaHora = hora;
        ultimoMinuto = minuto;
        ultimoSegundo = segundo;
        ultimaHoraSincronizada = millis();
        horaSincronizada = true;
        
        Serial.printf("[NTP] Hora sincronizada: %s\n", formatTime(hora, minuto, segundo).c_str());
        return;
      } else {
        Serial.println("[NTP] FallÃ³ sincronizaciÃ³n, usando hora local");
      }
    } else {
      hora = timeClient.getHours();
      minuto = timeClient.getMinutes();
      segundo = timeClient.getSeconds();
      return;
    }
  }
  
  // FALLBACK: calcular hora basada en Ãºltima sincronizaciÃ³n
  unsigned long tiempoTranscurrido = millis() - ultimaHoraSincronizada;
  unsigned long segundosTotales = (ultimaHora * 3600UL) + (ultimoMinuto * 60UL) + ultimoSegundo;
  segundosTotales += (tiempoTranscurrido / 1000);
  
  hora = (segundosTotales / 3600) % 24;
  minuto = (segundosTotales % 3600) / 60;
  segundo = segundosTotales % 60;
}

// =================== TAREA FIREBASE ===================
void firebaseProcessData(AsyncResult &aResult) {
  if (!aResult.isResult()) return;

  if (aResult.isEvent()) {
    Serial.printf("[Firebase] Evento: %s, msg: %s, code: %d\n", 
                  aResult.uid().c_str(), 
                  aResult.eventLog().message().c_str(), 
                  aResult.eventLog().code());
  }

  if (aResult.isDebug()) {
    Serial.printf("[Firebase] Debug: %s, msg: %s\n", 
                  aResult.uid().c_str(), 
                  aResult.debug().c_str());
  }

  if (aResult.isError()) {
    Serial.printf("[Firebase] Error: %s, msg: %s, code: %d\n", 
                  aResult.uid().c_str(), 
                  aResult.error().message().c_str(), 
                  aResult.error().code());
  }

  if (aResult.available()) {
    Serial.printf("[Firebase] âœ… Task completado: %s\n", aResult.uid().c_str());
  }
}

void sendDataToFirebase() {
  if (!firebaseInitialized || !app.ready()) return;

  int hora, minuto, segundo;
  obtenerHoraActual(hora, minuto, segundo);
  String timestampStr = formatTime(hora, minuto, segundo);

  // Enviar datos individualmente a Firebase
  Database.set<int>(async_client, "/cultivo/datos/nivel_agua", nivelAguaOK ? 100 : 0, firebaseProcessData, "fbNivel");
  delay(50);
  Database.set<float>(async_client, "/cultivo/datos/temperatura", lastTemp, firebaseProcessData, "fbTemp");
  delay(50);
  Database.set<int>(async_client, "/cultivo/datos/humedad_suelo", lastSoilPercent, firebaseProcessData, "fbHSuelo");
  delay(50);
  Database.set<int>(async_client, "/cultivo/datos/humedad_aire", (int)lastHum, firebaseProcessData, "fbHAire");
  delay(50);
  Database.set<float>(async_client, "/cultivo/datos/ph", lastPH, firebaseProcessData, "fbPH");
  delay(50);
  Database.set<bool>(async_client, "/cultivo/datos/bomba", bombaEncendida, firebaseProcessData, "fbBomba");
  delay(50);
  Database.set<bool>(async_client, "/cultivo/datos/valvula", (digitalRead(RELAY_VALVULA) == LOW), firebaseProcessData, "fbValvula");
  delay(50);
  Database.set<String>(async_client, "/cultivo/datos/timestamp", timestampStr, firebaseProcessData, "fbTimestamp");

  Serial.printf("[Firebase] ðŸ“Š Datos enviados: Nivel=%s, Temp=%.1f, HumSuelo=%d%%, HumAire=%.1f%%, Bomba=%s, Valvula=%s\n",
                nivelAguaOK ? "OK" : "BAJO", lastTemp, lastSoilPercent, lastHum,
                bombaEncendida ? "ON" : "OFF", 
                (digitalRead(RELAY_VALVULA) == LOW) ? "OPEN" : "CLOSED");
}

void FirebaseTask(void *pvParameters) {
  (void) pvParameters;
  
  Serial.println("[Firebase] Iniciando tarea Firebase...");
  
  // Esperar a que WiFi estÃ© conectado
  while (!wifiConectado) {
    RTOS_DELAY(1000);
  }

  // Configurar cliente SSL
  ssl_client.setInsecure();
  ssl_client.setTimeout(1000);
  async_client.setClient(ssl_client);

  // Inicializar Firebase
  initializeApp(async_client, app, getAuth(user_auth), firebaseProcessData, "fbAuth");
  app.getApp<RealtimeDatabase>(Database);
  Database.url(FIREBASE_URL);

  // Esperar autenticaciÃ³n
  Serial.println("[Firebase] Esperando autenticaciÃ³n...");
  while (!app.ready()) {
    app.loop();
    RTOS_DELAY(100);
  }

  firebaseInitialized = true;
  Serial.println("[Firebase] âœ… AutenticaciÃ³n exitosa");

  for (;;) {
    app.loop();

    if (firebaseInitialized && app.ready()) {
      unsigned long currentMillis = millis();
      if (currentMillis - lastFirebaseSend >= FIREBASE_INTERVAL) {
        lastFirebaseSend = currentMillis;
        sendDataToFirebase();
      }
    }

    RTOS_DELAY(1000);
  }
}

// =================== TAREAS EXISTENTES (MODIFICADAS) ===================
// --- Tarea de Sensores ---
void SensoresTask(void *pvParameters) {
  (void) pvParameters;

  pinMode(PH_PIN, INPUT);
  pinMode(SOIL_PIN, INPUT);
  pinMode(NIVEL_PIN, INPUT_PULLUP);
  dht.begin();
  
  Serial.println("[Sensores] Tarea iniciada");

  unsigned long lastSensorRead = 0;
  unsigned long lastPrint = 0;

  for (;;) {
    unsigned long currentMillis = millis();
    
    if (currentMillis - lastSensorRead >= 2000) {
      lastSensorRead = currentMillis;
      
      // Leer sensor de nivel
      bool nivelLeido = (digitalRead(NIVEL_PIN) == LOW);
      if (nivelLeido != nivelAguaOK) {
        nivelAguaOK = nivelLeido;
        Serial.printf("[Sensores] Nivel agua: %s\n", nivelAguaOK ? "OK" : "BAJO");
      }

      // Leer humedad suelo
      int soilRaw = analogRead(SOIL_PIN);
      int soilPercent = map(soilRaw, SOIL_DRY_VALUE, SOIL_WET_VALUE, 0, 100);
      soilPercent = constrain(soilPercent, 0, 100);
      
      if (soilPercent != lastSoilPercent) {
        lastSoilPercent = soilPercent;
        lastSoil = soilRaw;
      }

      // Leer DHT22
      float temp = dht.readTemperature();
      float hum = dht.readHumidity();
      
      if (!isnan(temp)) lastTemp = temp;
      if (!isnan(hum)) lastHum = hum;

      // Leer pH
      if (MEDIR_PH) {
        int phRaw = analogRead(PH_PIN);
        float voltage = phRaw * (3.3 / 4095.0);
        lastPH = 7.0 + ((voltage - 2.5) / 0.18);
      }
    }

    if (currentMillis - lastPrint >= 10000) {
      lastPrint = currentMillis;
      
      int hora, minuto, segundo;
      obtenerHoraActual(hora, minuto, segundo);
      String timestamp = formatTime(hora, minuto, segundo);
      
      String modo = wifiConectado ? "" : " [SIN WIFI]";
      String ntpStatus = horaSincronizada ? " [NTP OK]" : " [HORA LOCAL]";
      
      Serial.printf("[%s] pH=%.2f, Humedad=%d%%, Temp=%.1fÂ°C, HumAire=%.1f%%, Nivel=%s%s%s\n",
              timestamp.c_str(), lastPH, lastSoilPercent, 
              lastTemp, lastHum, nivelAguaOK ? "OK" : "BAJO", modo.c_str(), ntpStatus.c_str());
    }

    RTOS_DELAY(500);
  }
}

// --- Tarea de Riego --- 
void RiegoTask(void *pvParameters) {
  (void) pvParameters;

  pinMode(RELAY_BOMBA, OUTPUT);
  pinMode(RELAY_VALVULA, OUTPUT);
  digitalWrite(RELAY_BOMBA, HIGH);
  digitalWrite(RELAY_VALVULA, HIGH);

  Serial.println("[Riego] Tarea iniciada - Control automÃ¡tico de bomba");

  unsigned long lastControlTime = 0;
  unsigned long inicioExtemporaneo = 0;
  bool extemporaneoActivo = false;
  bool extemporaneoRealizado[3] = {false, false, false};
  const unsigned long DURACION_EXTEMPORANEO = 4 * 60 * 1000; // 4 minutos

  for (;;) {
    unsigned long currentMillis = millis();
    
    if (currentMillis - lastControlTime >= 2000) {
      lastControlTime = currentMillis;
      
      int horaActual, minutoActual, segundoActual;
      obtenerHoraActual(horaActual, minutoActual, segundoActual);

      // RESETEAR MARCAS DE RIEGOS EXTRA A MEDIA NOCHE
      if (horaActual == 0 && minutoActual == 0 && segundoActual < 5) {
        for (int i = 0; i < 3; i++) extemporaneoRealizado[i] = false;
      }
      
      if (bombaManual) continue;

      // CONTROL DE VÃLVULA
      if (!valvulaManual) {
        bool dentroHorarioLlenado = (horaActual >= HORA_INICIO_LLENADO || horaActual < HORA_FIN_LLENADO);

        if (dentroHorarioLlenado && !nivelAguaOK && !llenandoTanque) {
          Serial.println("[Riego] Iniciando llenado automÃ¡tico");
          llenandoTanque = true;
          digitalWrite(RELAY_VALVULA, LOW);
        }
        
        if (llenandoTanque && (nivelAguaOK || !dentroHorarioLlenado)) {
          Serial.println("[Riego] Deteniendo llenado automÃ¡tico");
          digitalWrite(RELAY_VALVULA, HIGH);
          llenandoTanque = false;
        }
      }

      // CONTROL DE RIEGOS EXTEMPORÃNEOS
      int horasExt[3] = {HORA_ext_ini1, HORA_ext_ini2, HORA_ext_ini3};

      for (int i = 0; i < 3; i++) {
        if (!extemporaneoRealizado[i] && horaActual == horasExt[i] && minutoActual == 0) {
          Serial.printf("[Riego] ðŸ’¦ Iniciando riego extemporÃ¡neo %d a las %02d:00\n", i+1, horasExt[i]);
          extemporaneoActivo = true;
          inicioExtemporaneo = currentMillis;
          bombaEncendida = true;
          digitalWrite(RELAY_BOMBA, LOW);
          extemporaneoRealizado[i] = true;
        }
      }

      if (extemporaneoActivo) {
        if (currentMillis - inicioExtemporaneo >= DURACION_EXTEMPORANEO) {
          extemporaneoActivo = false;
          bombaEncendida = false;
          digitalWrite(RELAY_BOMBA, HIGH);
          Serial.println("[Riego] ðŸ’§ Riego extemporÃ¡neo finalizado");
        }
      }

      // SISTEMA DE RIEGO PRINCIPAL
      bool dentroHorarioRiego = (horaActual >= HORA_INICIO_RIEGO && horaActual < HORA_FIN_RIEGO);
      
      if (dentroHorarioRiego && !extemporaneoActivo) {
        if (!cicloActivo) {
          cicloActivo = true;
          bombaEncendida = true;
          cicloStart = currentMillis;
          digitalWrite(RELAY_BOMBA, LOW);
          Serial.printf("[Riego] ðŸ’§ BOMBA ENCENDIDA - Ciclo %lu min encendido / %lu min apagado\n", 
                       TIEMPO_RIEGO/60000, TIEMPO_DESCANSO/60000);
        } else {
          unsigned long tiempoTranscurrido = currentMillis - cicloStart;
          
          if (bombaEncendida && tiempoTranscurrido >= TIEMPO_RIEGO) {
            bombaEncendida = false;
            cicloStart = currentMillis;
            digitalWrite(RELAY_BOMBA, HIGH);
            Serial.printf("[Riego] ðŸ’§ Bomba APAGADA - Descanso %lu min\n", TIEMPO_DESCANSO/60000);
          } else if (!bombaEncendida && tiempoTranscurrido >= TIEMPO_DESCANSO) {
            bombaEncendida = true;
            cicloStart = currentMillis;
            digitalWrite(RELAY_BOMBA, LOW);
            Serial.printf("[Riego] ðŸ’§ BOMBA ENCENDIDA - Ciclo %lu min\n", TIEMPO_RIEGO/60000);
          }
        }
      } else if (!dentroHorarioRiego && !extemporaneoActivo) {
        if (cicloActivo || bombaEncendida) {
          cicloActivo = false;
          bombaEncendida = false;
          digitalWrite(RELAY_BOMBA, HIGH);
          Serial.println("[Riego] ðŸ’§ Riego DETENIDO - Fuera de horario");
        }
      }
    }

    RTOS_DELAY(500);
  }
}

// --- Tarea WiFi ---
void WifiTask(void *pvParameters) {
  (void) pvParameters;

  pinMode(LED_WIFI_PIN, OUTPUT);
  digitalWrite(LED_WIFI_PIN, LOW);
  Serial.println("[WiFi] Iniciando conexiÃ³n...");
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  bool conectado = false;
  unsigned long lastReconnectAttempt = 0;

  for (;;) {
    unsigned long currentMillis = millis();
    
    if (WiFi.status() == WL_CONNECTED) {
      if (!conectado) {
        conectado = true;
        wifiConectado = true;
        digitalWrite(LED_WIFI_PIN, HIGH);
        Serial.println("[WiFi] âœ… CONECTADO");
        Serial.print("[WiFi] IP: ");
        Serial.println(WiFi.localIP());
        
        timeClient.begin();
        RTOS_DELAY(1000);
        
        if (timeClient.update()) {
          ultimaHora = timeClient.getHours();
          ultimoMinuto = timeClient.getMinutes();
          ultimoSegundo = timeClient.getSeconds();
          ultimaHoraSincronizada = currentMillis;
          horaSincronizada = true;
          Serial.printf("[NTP] âœ… Hora inicial: %s\n", 
                       formatTime(ultimaHora, ultimoMinuto, ultimoSegundo).c_str());
        } else {
          Serial.println("[NTP]  FallÃ³ sincronizaciÃ³n inicial");
        }
      }
      
      digitalWrite(LED_WIFI_PIN, HIGH);
      
    } else {
      if (conectado) {
        conectado = false;
        wifiConectado = false;
        horaSincronizada = false;
        firebaseInitialized = false;
        Serial.println("[WiFi]  DESCONECTADO");
      }
      
      digitalWrite(LED_WIFI_PIN, (currentMillis % 2000 < 1000) ? HIGH : LOW);
      
      if (currentMillis - lastReconnectAttempt >= 30000) {
        Serial.println("[WiFi] ðŸ”„ Intentando reconectar...");
        WiFi.disconnect();
        WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
        lastReconnectAttempt = currentMillis;
      }
    }

    RTOS_DELAY(1000);
  }
}

// --- Tarea Telegram ---
void TelegramTask(void *pvParameters) {
  (void) pvParameters;
  client.setInsecure();
  Serial.println("[Telegram] Tarea iniciada");
  bool primerMensajeEnviado = false;
  unsigned long lastTelegramCheck = 0;

  for (;;) {
    unsigned long currentMillis = millis();
    
    if (wifiConectado) {
      if (!primerMensajeEnviado) {
        String ip = WiFi.localIP().toString();
        String mensaje = "ðŸ¤– *Sistema de Riego Conectado!* ðŸŒ±\n\n";
        mensaje += "ðŸ“¡ IP: " + ip + "\n";
        mensaje += "ðŸ‡¨ðŸ‡´ *Zona Horaria:* Colombia (UTC-5)\n";
        mensaje += "â° *Hora Sistema:* " + formatTime(ultimaHora, ultimoMinuto, ultimoSegundo) + "\n";
        mensaje += "ðŸ’§ *Modo:* Riego automÃ¡tico \n";
        mensaje += "â±ï¸ *Ciclo:* " + String(TIEMPO_RIEGO/60000) + "min ON / " + String(TIEMPO_DESCANSO/60000) + "min OFF\n";
        mensaje += "ðŸ“Š *Firebase:* " + String(firebaseInitialized ? "âœ… CONECTADO" : "â³ CONECTANDO") + "\n\n";
        mensaje += "Usa /help para ver comandos";
        
        bot.sendMessage(CHAT_ID, mensaje, "Markdown");
        primerMensajeEnviado = true;
        Serial.println("[Telegram] Mensaje de bienvenida enviado");
      }

      if (currentMillis - lastTelegramCheck >= 3000) {
        lastTelegramCheck = currentMillis;
        
        try {
          int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
          
          if (numNewMessages > 0) {
             Serial.printf("[Telegram] %d mensajes nuevos\n", numNewMessages);
            
            for (int i = 0; i < numNewMessages; i++) {
              String chat_id = String(bot.messages[i].chat_id);
              String text = bot.messages[i].text;

              if (!autorizado(chat_id)) {
                bot.sendMessage(chat_id, "â›” Acceso denegado", "");
                continue;
              }

              
              if (text == "/start" || text == "/help") {
                String welcome = "ðŸŒ± *Sistema de Riego AutomÃ¡tico* ðŸ¤–\n\n";
                welcome += "ðŸ’§ *MODO ESPECIAL:* Riego \n\n";
                welcome += "ðŸ“‹ *Comandos:*\n";
                welcome += "/estado - Estado del sistema\n";
                welcome += "/abrirvalvula - Abrir vÃ¡lvula (modo manual)\n";
                welcome += "/cerrarvalvula - Cerrar vÃ¡lvula (modo manual)\n";
                welcome += "/encenderbomba - encender bomba (modo manual)\n";
                welcome += "/apagarbomba - apagar bomba (modo manual)\n";
                welcome += "/config - ConfiguraciÃ³n actual\n";
                welcome += "/help - Ayuda";
                bot.sendMessage(chat_id, welcome, "Markdown");
              }
              else if (text == "/estado") {
                int hora, minuto, segundo;
                obtenerHoraActual(hora, minuto, segundo);
                String estado = "ðŸ“Š *ESTADO DEL SISTEMA*\n";
                estado += "â° " + formatTime(hora, minuto, segundo) + "\n\n";
                estado += "ðŸ’§ *Humedad de la Raiz:* " + String(lastSoilPercent) + "%\n";
                estado += "ðŸŒ¡ï¸ *Temperatura:* " + String(lastTemp, 1) + "Â°C\n";
                estado += "ðŸ’¦ *Humedad Aire:* " + String(lastHum, 1) + "%\n";
                estado += "ðŸ§ª *pH:* " + String(lastPH, 2) + "\n";
                estado += "ðŸ’§ *Nivel Agua:* " + String(nivelAguaOK ? "âœ… OK" : "âš ï¸ BAJO") + "\n";
                estado += "ðŸ”Œ *Bomba:* " + String(bombaEncendida ? "âœ… ENCENDIDA" : "âŒ APAGADA");
                estado += String(bombaManual ? " (MANUAL)" : " (AUTO)") + "\n";
                estado += "ðŸš° *VÃ¡lvula:* " + String((digitalRead(RELAY_VALVULA) == LOW) ? "âœ… ABIERTA" : "âŒ CERRADA");
                estado += String(valvulaManual ? " (MANUAL)" : " (AUTO)") + "\n";
                estado += "ðŸ“Š *Firebase:* " + String(firebaseInitialized ? "âœ… CONECTADO" : "âŒ DESCONECTADO") + "\n";
                bot.sendMessage(chat_id, estado, "Markdown");
              }
              else if (text == "/abrirvalvula") {
                digitalWrite(RELAY_VALVULA, LOW);
                valvulaManual = true;
                llenandoTanque = true;
                bot.sendMessage(chat_id, "âœ… *VÃ¡lvula abierta en modo MANUAL*\n\nSe mantendrÃ¡ abierta hasta que uses /cerrarvalvula", "Markdown");
              }
              else if (text == "/cerrarvalvula") {
                digitalWrite(RELAY_VALVULA, HIGH);
                valvulaManual = false;
                llenandoTanque = false;
                bot.sendMessage(chat_id, " *VÃ¡lvula cerrada - Modo AUTOMÃTICO activado*", "Markdown");
              }
              else if (text == "/encenderbomba") {
                digitalWrite(RELAY_BOMBA, LOW);
                bombaManual = true;
                bombaEncendida = true;
                bot.sendMessage(chat_id, " *Bomba abierta en modo MANUAL*\n\nSe mantendrÃ¡ abierta hasta que uses /apagarbomba", "Markdown");
              }
              else if (text == "/apagarbomba") {
                digitalWrite(RELAY_BOMBA, HIGH);
                bombaManual = false;
                bombaEncendida = false;
                bot.sendMessage(chat_id, " *BOMBA APAGADA*\n\nModo AUTOMÃTICO restaurado", "Markdown");
              }
             
              else if (text == "/config") {
                String config = "âš™ï¸ *CONFIGURACIÃ“N ACTUAL*\n\n";
                config += "ðŸ•’ *Horario Riego:* " + String(HORA_INICIO_RIEGO) + ":00 - " + String(HORA_FIN_RIEGO) + ":00\n";
                config += "ðŸ’§ *Horario Llenado:* " + String(HORA_INICIO_LLENADO) + ":00 - " + String(HORA_FIN_LLENADO) + ":00\n";
                config += "â±ï¸ *Ciclo Riego:* " + String(TIEMPO_RIEGO/60000) + "min ON / " + String(TIEMPO_DESCANSO/60000) + "min OFF\n";
                config += "ðŸ’¡ *MODO ESPECIAL:* Riego SIN verificaciÃ³n de nivel\n";
                config += "ðŸš° *Modo Bomba:* " + String(bombaManual ? "MANUAL" : "AUTOMÃTICO");
                config += "ðŸš° *Modo VÃ¡lvula:* " + String(valvulaManual ? "MANUAL" : "AUTOMÃTICO");
                config += "ðŸ“Š *Firebase:* " + String(firebaseInitialized ? "âœ… CONECTADO" : "âŒ DESCONECTADO") + "\n";
                bot.sendMessage(chat_id, config, "Markdown");
              }
            }
          }
        } catch (...) {
          Serial.println("[Telegram] Error temporal");
        }
      }
    } else {
      primerMensajeEnviado = false;
    }

    RTOS_DELAY(1000);
  }
}

// =================== SETUP ===================
void setup() {
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("\n" + String(80, '='));
  Serial.println("ðŸŒ± SISTEMA DE RIEGO + TELEGRAM + FIREBASE ðŸ¤–");
  Serial.println("ðŸ‡¨ðŸ‡´ Zona Horaria: Colombia (UTC-5)");
  Serial.println("ðŸ’§ MODO: Riego automÃ¡tico");
  Serial.println("â±ï¸  Ciclo: " + String(TIEMPO_RIEGO/60000) + "min ON / " + String(TIEMPO_DESCANSO/60000) + "min OFF");
  Serial.println("ðŸ“Š Firebase: Habilitado cada minuto");
  Serial.println(String(80, '='));

  // Inicializar tiempo por defecto
  ultimaHora = HORA_INICIO_RIEGO;
  ultimoMinuto = 0;
  ultimoSegundo = 0;
  ultimaHoraSincronizada = millis();

  // Configurar pines
  pinMode(RELAY_BOMBA, OUTPUT);
  pinMode(RELAY_VALVULA, OUTPUT);
  pinMode(LED_WIFI_PIN, OUTPUT);
  digitalWrite(RELAY_BOMBA, HIGH);
  digitalWrite(RELAY_VALVULA, HIGH);
  digitalWrite(LED_WIFI_PIN, LOW);

  dht.begin();

  // Crear tareas
  xTaskCreatePinnedToCore(SensoresTask, "Sensores", 6144, NULL, 1, &TaskSensorsHandle, 1);
  xTaskCreatePinnedToCore(RiegoTask, "Riego", 6144, NULL, 2, &TaskRiegoHandle, 1);
  xTaskCreatePinnedToCore(WifiTask, "WiFi", 6144, NULL, 1, &TaskWifiHandle, 0);
  xTaskCreatePinnedToCore(TelegramTask, "Telegram", 8192, NULL, 1, &TaskTelegramHandle, 1);
  xTaskCreatePinnedToCore(FirebaseTask, "Firebase", 8192, NULL, 1, &TaskFirebaseHandle, 1);

  Serial.println("âœ… Sistema iniciado - Riego automÃ¡tico + Firebase activos");
}

void loop() {
  static unsigned long lastStatus = 0;
  if (millis() - lastStatus > 30000) {
    int hora, minuto, segundo;
    obtenerHoraActual(hora, minuto, segundo);
    Serial.printf("[Sistema] Hora: %s, WiFi: %s, NTP: %s, Firebase: %s, Bomba: %s, VÃ¡lvula: %s %s\n", 
                  formatTime(hora, minuto, segundo).c_str(),
                  wifiConectado ? "OK" : "NO",
                  horaSincronizada ? "OK" : "LOCAL", 
                  firebaseInitialized ? "OK" : "NO",
                  bombaEncendida ? "ON" : "OFF",
                  (digitalRead(RELAY_VALVULA) == LOW) ? "OPEN" : "CLOSED",
                  valvulaManual ? "(MANUAL)" : "(AUTO)");
    lastStatus = millis();
  }
  
  RTOS_DELAY(5000);
}
